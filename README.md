# firmware for qr-scanner и card-colum

### target:
обеспечить взаимодействие с сервером(java) по управлению и администрированию вьезда/выезда с данными устройствами

# Общие требования к прошивке

### Общее описание:
Требуется прошивка для системы устройств, состоящей из сканера QR меток (через HTTP) и коллон предназначенных для выдачи карт. Также прошивка должна иметь возможность отправлять и принимать HTTP запросы на/от ниже описанных endpoint-в. Краткое описание деятельности системы: сканер qr сканирует на вьезде имеющийся у водителя qr-code(внутри qr кода есть метаданные в формате json, которые необходимо передать на сервер), если данный qr проходит проверку, то надо послать команду в колонну на выдачу карты и оповестить об этом сервер, после этого открыть шлагбаум. Также существуют негативные кейсы, например отсутствие qr кода в базе данных на сервере или неисправность шлагбаума, или неисправность колонны, либо отсутствие коннекта с сервером и тд.
Для случаев критической неисправности каких то устройств в системе существует endpoint "/api/report", в который можно сообщить какое устройство вышло из строя.

### Необходимые требования:
1. Возможность тестировать функциональность прошивки локально с адресом платы localhost:8181 (или в качестве аргументов при запуске самостоятельно передавать host и port)
2. В случае если плата переживает экстренное выключение питания и программа приостанавливается, желательно посылать в "/api/report" ID устройства.
3. необходимое количество retry в случае если действие выполнено неуспешно

---

### описание работы базового функционала:

#### Запрос на осуществление въезда на предприятие и считывание qr - `POST api/qr/receiveQrCode/{deviceId}`

метод который нужно вызывать в момент считывания qr(когда на въезде водитель подносит qr-code к считывающему устройству), тем самым запрашивая въезд на территорию предприятия.

**Примечание:** после считывания qr, содержимое qr передается в формате json(в текущей реализации в не зашифрованном
виде) через http.

**Список параметров:**

```sh
в url надо передать deviceId, пример: /102

{
  "governmentNumber": "string",
  "uuid": "string"
}
```

**Формат ответа:**

```sh
без ответа, только статус код
```

**Статус:**

1. при успешной отработке - `HttpStatus.OK(200)`
2. при возникновении ошибки(например невалидный qr) - `HttpStatus.Forbidden(403)`
3. сервер недоступен - `HttpStatus.Internal_Server_Error(500)`

#### Вариант исполнения - 01(не целевой)
#### Оповещение о том, что карта выдана - `POST /api/cardColumn/giveCard`(такого метода в данный момент нету, на крайний случай)
данный метод должен вызываться после успешной выдачи карты посетителю(когда qr оказался валидным, после получения статуса 200 от `api/qrScanner/checkQrForEntry`), после успешной выдачи передается **result:** true или **result:** false в случае неуспешной выдачи. Имеет смысл обьединять данное действие с событием считывания qr(чтобы иметь возможность откатить транзакцию целиком)

**Список параметров:**
```sh
{
    "id": 50 - id qr кода,
    "result": true
    "cardNumber": "123456" - заполняется только при успешной выдачи
}
```

**Формат ответа:**
```sh
50 - id проверяемого qr code(в формате long)
```

**Статус:**
1. при успешной отработке - `HttpStatus.OK(200)`
2. сервер недоступен - `HttpStatus.Internal_Server_Error(500)`

#### Вариант исполнения - 02(целевой)
### метод на устройстве slave который выдает карту из колонны - `POST api/card/giveCard/{deviceId}`

данный метод вызывается с бекенда в прошивку для выдачи карты посетителю. При неудачной выдаче необходимо снова прикладывать qr, и цикл повторяется снова, пока не будет выдана карта. Либо будет доступна принудительное открытие с фронта.

**Список параметров передается в url:**
```sh
{
    "deviceId": 51234 - deviceId колонны, которая должна выдать карту
}
```

**Статус:**
1. при успешной отработке - `HttpStatus.OK(200)`
2. сервер/устройство недоступно - `HttpStatus.Internal_Server_Error(500)`

#### Осуществление выезда, когда карта вернулась в колонну - `POST api/card/return/{id}`

данный метод вызывается с прошивки когда карточка вернулась в колоннку. На стороне бека проверяется наличие такой
карточки в базе, открытие шлагбаума, удаление записи о метадате карточки из базы данных при успешном открытии шлагбаума.
Если бек ответил ошибкой, то карту необходимо вернуть обратно.

**Список параметров передается в url:**

```sh
/{id}?deviceId={deviceId}

id - идентификатор карточки
deviceId - номер устройства с которого пришел запрос
```

**Формат ответа:**

```sh
50 - возвращается id созданного qr
```

**Статус:**

1. при успешной отработке - `HttpStatus.OK(200)`
2. при возникновении ошибки(например не удалось открыть шлагбаум) - `HttpStatus.Forbidden(409)`, нужно для отображения
   на фронте информации, также для оповещения прошивки, что она вернула карту
3. сервер недоступен - `HttpStatus.Internal_Server_Error(500)`

---
#### Оповещение о том, что карт в колонне становится критически мало  - `POST /api/cardColumn/lowCountCards`(в первом релизе данный функционал использоваться не будет)
на плате периодически происходит проверка кол-ва карт в колоннах. Если количество карт становится меньше критического, то посылаем алерт на сервер.

**Список параметров:**
```sh
{
    "id": 50 - id устройства,
}
```

**Формат ответа:**
```sh
не предусматривает ответ от сервера
```

**Статус:**
1. при успешной отработке - `HttpStatus.OK(200)`
2. сервер недоступен - `HttpStatus.Internal_Server_Error(500)`


#### Общая методика регистрации для всех устройств типа slave
### Регистрация платы внутри программы - `POST device-registration-core/api/registration` - запрос с платы на сервер
Метод предназначенный для регистрации платы в нашей программе для дальнейшей идентификации плат и подконтрольных им устройств во время работы. Внутри платы должен быть флажок, что плата зарегистрирована, и плата должна совершать запросы на сервер до тех пор, пока не зарегистрируется успешно.

**Формат запроса:**
```
{
     "group": число в формате long, при первой регистрации null
     "address" :  "192.168.10.98:8080",
     “groups”: [
	    {
            	"id": 1234657,
            	"type" : ”RFID"
	    },
	    {
		"id": 87654428,
		"type" : “ENTRY"
	    }
    ]
}
```

**Формат ответа:**
```sh
{
    "group_id": уникальный идентификатор группы, long,
}
```
HTTP Status 200 - в случае успешной регистрации,
HTTP Status 400 - в случае неудачной регистрации.

### Сообщение о критической ошибке модуля - `POST device-registration-core/api/report` - запрос с платы на сервер(в первом релизе данный функционал использоваться не будет)
Метод предназначенный для сообщения в приложение о критических ошибках работы шлагбаума или считывателя RFID меток.
В данный метод нужно посылать запрос до получения статуса 200, чтобы убедиться в том, что наш сервер узнал о критической ошибке какого либо устройства.

**Список параметров:**
`@RequestParam {String report}` - содержащая индетификатор неисправного устройства.

**Формат ответа:**
HTTP Status 200 - в случае успешного получения сервером информации.

**Возможные ошибки**
В случае недоступности сервера HTTP Status 500.
